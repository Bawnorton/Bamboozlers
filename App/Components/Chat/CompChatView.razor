@implements IAsyncDisposable
@using Bamboozlers.Classes.AppDbContext
@using Bamboozlers.Classes.Data
@using Bamboozlers.Classes.Networking
@using Bamboozlers.Classes.Networking.Packets
@using Bamboozlers.Classes.Networking.Packets.Clientbound
@using Bamboozlers.Classes.Networking.Packets.Serverbound
@using Bamboozlers.Classes.Networking.SignalR
@using Bamboozlers.Classes.Services
@using Microsoft.AspNetCore.SignalR.Client
@using Bamboozlers.Classes
@using Blazorise.Extensions
@using AngleSharp.Diffing.Extensions
@using System.Text.Json
@using Bamboozlers.Classes.Collections
@inherits UserViewComponentBase

@inject IDbContextFactory<AppDbContext> Db
@inject NavigationManager NavigationManager
@inject IJSRuntime JsRuntime
@inject IKeyPressService KeyPressService
@inject AuthenticationStateProvider AuthenticationStateProvider

<!--suppress JSVoidFunctionReturnValueUsed, JSUnresolvedReference -->
<script>
    function showConfirmDialog(message) {
        return Swal.fire({
            title: 'Are you sure?',
            text: message,
            color: '#d33',
            icon: 'warning',
            iconColor:'#d33',
            showCancelButton: true,
            confirmButtonColor: '#d33',
            cancelButtonColor: '#247352',
            confirmButtonText: 'Yes',
            background: '#343a40',
        }).then((result) => {
            return result.isConfirmed;
        });
    }
    
    function waitForElm(selector) {
        return new Promise(resolve => {
            if (document.querySelector(selector)) {
                return resolve(document.querySelector(selector));
            }
    
            const observer = new MutationObserver(_ => {
                if (document.querySelector(selector)) {
                    observer.disconnect();
                    resolve(document.querySelector(selector));
                }
            });
    
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        });
    }
    
    function resizeTextarea(textarea) {
        textarea.style.height = '1px';
        textarea.style.height = (textarea.scrollHeight) + 'px';
    }
    
    waitForElm("#message-input").then(textarea => {
        textarea.addEventListener('input', () => resizeTextarea(textarea));
        textarea.addEventListener('keydown', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                e.stopPropagation();
            }
        });
        resizeTextarea(textarea);
        textarea.focus();
    });
</script>

<Layout>
    <LayoutHeader Fixed
                  Padding="Padding.Is3"
                  TextSize="TextSize.Heading5"
                  TextColor="TextColor.Primary"
                  Background="Background.Dark"
                  Display="Display.InlineFlex"
                  Class="justify-content-between align-items-center">
        <Div>
            @if (Chat is GroupChat { Avatar: not null } groupChat)
            {
                <Image Source=@($"data:image/png;base64,{Convert.ToBase64String(groupChat.Avatar)}") Class="message-avatar" alt=""/>
            }
            else if (Chat is not null && Chat is not GroupChat && Chat.Users.First(f => f.Id != Self.Id).Avatar != null)
            {
                <Image Source=@($"data:image/png;base64,{Convert.ToBase64String(Chat.Users.First(f => f.Id != Self.Id).Avatar!)}") Class="message-avatar" alt=""/>
            }
            <Text ElementId="header-text">@ChatName</Text>
        </Div>

        @if (IsMod)
        {
            <Icon ElementId="settingsbtn" Name="IconName.Settings" role="button" @onclick="() => CompChatSettings.ShowModal()"/>
        }

    </LayoutHeader>
    <LayoutContent Padding="Padding.Is3" ElementId="message-container" Class="scrollbar-container h-100">
        <Alert Color="@AlertColor" @bind-Visible="@AlertVisible">
            <AlertMessage>
                @AlertMessage
                <CloseButton Style="--bs-btn-close-white-filter: black;" VerticalAlignment="VerticalAlignment.Middle" Float="Float.End" TextColor="TextColor.Warning"/>
            </AlertMessage>
        </Alert>
        <Layout>
            <LayoutContent>
                <Div>
                    <CascadingValue Value="new ChatContextData(IsShiftHeld, IsMod, DeleteMessage, EditMessage)">
                        @foreach (var message in Messages)
                        {
                            <CompMessageView
                                Message="message.DbMessage"
                                PreviousMessage="@message.Previous?.DbMessage"
                                EchoRecieved="@message.EchoRecieved"/>
                        }
                    </CascadingValue>
                </Div>
            </LayoutContent>
        </Layout>
    </LayoutContent>
    <LayoutFooter>
        <Div Position="Position.Sticky" Background="Background.Secondary" TextColor="TextColor.Light" Class="m-4" Style="bottom: 0; border-radius: 5px;">
            <Div Display="Display.Flex" Overflow="Overflow.Hidden">
                <textarea id="message-input" placeholder="@($"Message {ChatName}")" class="message-input p-3" @onkeyup="OnInput" @bind="MessageInput" @bind:event="oninput">
                </textarea>
            </Div>
        </Div>
    </LayoutFooter>
</Layout>
@if (Chat is GroupChat)
{
    <LayoutSider>
        <LayoutSiderContent>
            <Bar Mode="BarMode.VerticalInline"
                 CollapseMode="BarCollapseMode.Hide"
                 ThemeContrast="ThemeContrast.Dark"
                 Class="h-100">
                <BarMenu>
                    <BarItem Class="mb-2">
                        <Div TextColor="TextColor.Primary"
                             Background="Background.Dark"
                             Padding="Padding.Is3"
                             TextSize="TextSize.Heading5">
                            <Text Class="me-4">Members - @Chat.Users.Count</Text>
                            @if (IsMod)
                            {
                                <Icon ElementId="addMembers" role="button" Name="IconName.Add" @onclick="() => CompAddMember.ShowModal()"/>
                            }
                        </Div>
                    </BarItem>
                    @foreach (var friend in Chat.Users)
                    {
                        <BarItem>
                            <BarLink Flex="Flex.JustifyContent.Between" class="align-items-center rounded" Display="Display.Flex">
                                <Div>
                                    @if (friend.Avatar != null)
                                    {
                                        <Image Source=@($"data:image/png;base64,{Convert.ToBase64String(friend.Avatar)}") Class="message-avatar" alt=""/>
                                    }

                                    @(friend.DisplayName ?? friend.UserName)
                                </Div>

                                @if (IsMod && friend.Id != Self.Id && friend.Id != ((Chat as GroupChat)!).OwnerID)
                                {
                                    <Paragraph TextSize="TextSize.Small" Display="Display.Inline"
                                               role="button" Class="text-decoration-underline mb-0 text-danger-emphasis"
                                               ElementId="removeMember"
                                               @onclick="() => RemoveMember(friend.Id)">
                                        Remove
                                    </Paragraph>
                                }
                            </BarLink>
                        </BarItem>
                    }
                </BarMenu>
            </Bar>
        </LayoutSiderContent>
    </LayoutSider>
}

@if (IsMod)
{
    <CompAddMember @ref="CompAddMember" OnAdd="@(usersAdded => UpdateMembers(usersAdded))" Chat="@(Chat as GroupChat)"/>
    <CompChatSettings @ref="CompChatSettings" Chat="@(Chat as GroupChat)" OnChange="SettingsChanged"/>
}

@code {
    [Parameter] public int ChatID { get; set; }
    private Chat? Chat { get; set; }
    private string ChatName { get; set; }

    private List<MessageEntry> Messages { get; set; } = [];
    private Dictionary<int, int> MessageIdToIndex { get; set; } = new();
    private List<int> EphemeralMessages { get; set; } = [];
    private DateTime? _lastMessageSentAt;
    
    private string MessageInput { get; set; }
    
    private User Self { get; set; }
    
    private bool IsMod { get; set; }

    private CompAddMember CompAddMember { get; set; }
    private CompChatSettings CompChatSettings { get; set; }
    
    private Color AlertColor { get; set; }
    private bool AlertVisible { get; set; }
    public string AlertMessage { get; private set; }
    
    private string _hubUrl;
    private HubConnection? _hubConnection;

    private bool IsShiftHeld { get; set; }

    protected override async Task OnInitializedAsync()
    {
        Self = (await AuthService.GetUser())!;
        
        await KeyPressService.StartListeningAsync();
        KeyPressService.KeyPressed += OnKeyPressed;
        KeyPressService.KeyReleased += OnKeyReleased;
    }

    protected override async Task OnParametersSetAsync()
    {
        await GetData();
        
        IsMod = IsModerator();
        
        await using var db = await Db.CreateDbContextAsync();
        Chat = await db.Chats
            .Include(c => c.Users)
            .FirstOrDefaultAsync(c => c.ID == ChatID);
        switch (Chat)
        {
            case null:
                throw new InvalidOperationException($"Chat from ID {ChatID} not found");
            case GroupChat groupChat:
                ChatName = groupChat.Name;
                break;
            default:
            {
                var self = await AuthService.GetUser();
                var other = Chat.Users.FirstOrDefault(u => u.Id != self!.Id) ?? self!;
                ChatName = (other.DisplayName ?? other.UserName)!;
                break;
            }
        }

        await UpdateMessages();
    }
    
    private bool IsModerator()
    {
        if (Chat is not GroupChat)
        {
            return false;
        }

        using var db = Db.CreateDbContext();
        var gc = db.GroupChats.Include(i => i.Moderators).First(f => f.ID == ChatID);
        return gc.OwnerID == Self.Id || gc.Moderators.Any(m => m.Id == Self.Id);
    }
    
    private async Task GetData()
    {
        await using var db = await Db.CreateDbContextAsync();
        Chat = await db.Chats.Include(i => i.Users)
            .Include(i => i.Messages)
            .FirstOrDefaultAsync(c => c.ID == ChatID);
        if (Chat is GroupChat groupChat)
        {
            ChatName = groupChat.Name;
        }
        else if (Chat is not null)
        {
            var other = Chat.Users.FirstOrDefault(u => u.Id != Self.Id) ?? Self;
            ChatName = (other.DisplayName ?? other.UserName)!;
        }
        else
        {
            throw new InvalidOperationException("Chat is null");
        }
    }
    
    private void ReIndexMessages()
    {
        MessageIdToIndex.Clear();
        for (var i = 0; i < Messages.Count; i++)
        {
            MessageIdToIndex[Messages[i].DbMessage.ID] = i;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        await Connect();
    }

    private async Task Connect()
    {
        var baseUrl = NavigationManager.BaseUri;
        _hubUrl = baseUrl.TrimEnd('/') + BamboozlersHub.HubUrl;

        _hubConnection = new HubConnectionBuilder()
            .WithUrl(_hubUrl, options =>
            {
                options.UseDefaultCredentials = true;
                options.HttpMessageHandlerFactory = innerHandler => new IncludeRequestCredentialsMessageHandler { InnerHandler = innerHandler };
            })
            .WithAutomaticReconnect([TimeSpan.Zero, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10)])
            .Build();
        
        _hubConnection.On("RecievePacketOnClient", async (string packetJson) =>
        {
            await ClientNetworkHandler.Instance.Handle(packetJson, async packet =>
            {
                switch (packet)
                {
                    case ReadDatabaseS2CPacket readDatabaseS2CPacket:
                        if (readDatabaseS2CPacket.DbEntry == DbEntry.ChatMessage)
                        {
                            await UpdateMessages();
                        }
                        break;
                    case MessageDeletedS2CPacket messageDeletedS2CPacket:
                        await RemoveClientMessage(messageDeletedS2CPacket.MessageId);
                        break;
                    case MessageEditedS2CPacket messageEditedS2CPacket:
                        var messageEntry = Messages[MessageIdToIndex[messageEditedS2CPacket.MessageId]];
                        messageEntry.DbMessage.Content = messageEditedS2CPacket.NewContent;
                        if(EphemeralMessages.Contains(messageEntry.DbMessage.ID)) return;
                        
                        messageEntry.EchoRecieved = true;
                        await InvokeAsync(StateHasChanged);
                        break;
                }
            });
        });

        await _hubConnection.StartAsync();

        await _hubConnection.SendAsync("JoinChat", ChatID);
    }

    private async Task SendToServer<T>(T packet) where T : IPacket
    {
        if (_hubConnection is null) throw new InvalidOperationException("Hub connection is not initialized");
        if (_hubConnection.State != HubConnectionState.Connected) throw new InvalidOperationException("Hub connection is not connected");
        await _hubConnection.SendAsync("ReceivePacketOnServer", packet.Serialize());
    }

    private async Task OnInput(KeyboardEventArgs eventArgs)
    {
        if (eventArgs.Key != "Enter" || eventArgs.ShiftKey) return;

        await SendMessage(MessageInput);
        MessageInput = "";
    }

    private async Task DeleteMessage(Message message)
    {
        await using var db = await Db.CreateDbContextAsync();
        db.Messages.Remove(message);
        await db.SaveChangesAsync();

        var messageUpdated = new MessageUpdatedC2SPacket
        {
            ChatId = ChatID,
            MessageId = message.ID,
            Deleted = true,
            UpdaterId = Self.Id
        };
        
        await SendToServer(messageUpdated);
    }

    private async Task RemoveClientMessage(int messageId)
    {
        var target = Messages[MessageIdToIndex[messageId]];
        if (target.Previous != null)
        {
            target.Previous.Next = target.Next;
        }
        if (target.Next != null)
        {
            target.Next.Previous = target.Previous;
        }
        Messages.Remove(target);
        ReIndexMessages();
                
        await InvokeAsync(StateHasChanged);
    }

    private async Task EditMessage(Message message, string newContent)
    {
        if (string.IsNullOrWhiteSpace(newContent)) return;

        while (newContent.EndsWith("\n")) newContent = newContent[..^1];
        while (newContent.StartsWith("\n")) newContent = newContent[1..];

        message.Content = newContent;
        Messages[MessageIdToIndex[message.ID]].EchoRecieved = false;
        
        await using var db = await Db.CreateDbContextAsync();
        db.Messages.Update(message);
        await db.SaveChangesAsync();
        
        var messageUpdated = new MessageUpdatedC2SPacket
        {
            ChatId = ChatID,
            MessageId = message.ID,
            NewContent = newContent,
            UpdaterId = Self.Id
        };
        
        await SendToServer(messageUpdated);
    }

    private async Task UpdateMessages()
    {
        var newMessages = await (await Db.CreateDbContextAsync()).Messages
            .Where(m => m.ChatID == Chat!.ID && (_lastMessageSentAt == null || m.SentAt > _lastMessageSentAt))
            .ToListAsync();
        if (newMessages.Count == 0) return;
        
        foreach (var message in newMessages)
        {
            if (EphemeralMessages.Contains(message.ID))
            {
                EphemeralMessages.Remove(message.ID);
                Messages[MessageIdToIndex[message.ID]].EchoRecieved = true;
            }
            else
            {
                CreateMessageEntry(message);
            }
        }
        
        _lastMessageSentAt = Messages[^1].DbMessage.SentAt;
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task SendMessage(string messageText)
    {
        if (string.IsNullOrWhiteSpace(messageText)) return;

        while (messageText.EndsWith("\n")) messageText = messageText[..^1];
        while (messageText.StartsWith("\n")) messageText = messageText[1..];

        var self = await AuthService.GetUser();
        var message = new Message
        {
            ChatID = ChatID,
            SenderID = self!.Id,
            Content = messageText,
            SentAt = DateTime.Now,
            IsPinned = false
        };
        await using var db = await Db.CreateDbContextAsync();

        db.Messages.Add(message);
        await db.SaveChangesAsync();

        var readDatabaseRequest = new TellOthersToReadDatabaseC2SPacket
        {
            SenderId = self.Id,
            ChatId = ChatID,
            DbEntry = DbEntry.ChatMessage
        };
        await SendToServer(readDatabaseRequest);
        
        CreateMessageEntry(message, ephemeral: true);
    }

    private MessageEntry CreateMessageEntry(Message message, bool ephemeral = false)
    {
        var lastMessage = Messages.Count == 0 ? null : Messages[^1];
        var messageEntry = new MessageEntry
        {
            DbMessage = message,
            Previous = lastMessage,
            Next = null,
            EchoRecieved = !ephemeral
        };
        if (lastMessage != null)
        {
            lastMessage.Next = messageEntry;
        }
        Messages.Add(messageEntry);
        MessageIdToIndex[message.ID] = Messages.Count - 1;
        if (ephemeral)
        {
            EphemeralMessages.Add(message.ID);
        }
        return messageEntry;
    }

    private void UpdateMembers(List<User> usersAdded)
    {
        if (!usersAdded.IsNullOrEmpty())
        {
            Chat!.Users.AddRange(usersAdded);
            AlertVisible = true;
            AlertMessage = "Member(s) added successfully!";
            AlertColor = Color.Success;
        }
        else
        {
            AlertVisible = true;
            AlertMessage = "No member(s) added!";
            AlertColor = Color.Warning;
        }
    }

    private async Task RemoveMember(int userID)
    {
        try
        {
            await using var db = await Db.CreateDbContextAsync();
            var user = db.Users.Include(i => i.Chats).FirstOrDefault(f => f.Id == userID);
            if (user is null)
            {
                AlertVisible = true;
                AlertMessage = "User not found";
                AlertColor = Color.Warning;
                return;
            }
            var confirmed = await JsRuntime.InvokeAsync<bool>("showConfirmDialog", $"Are you sure you want to remove {user.DisplayName ?? user.UserName}?");

            if (confirmed)
            {
                db.Chats.Include(i => i.Users).First(f => f.ID == Chat!.ID).Users.Remove(user);
                db.Users.Include(i => i.Chats).First(f => f.Id == userID).Chats.Remove(Chat!);
                db.Chats.OfType<GroupChat>().Include(i => i.Moderators).First(f => f.ID == Chat!.ID).Moderators.Remove(user);
                db.Users.Include(i => i.ModeratedChats).First(f => f.Id == userID).Chats.Remove(Chat!);
                await db.SaveChangesAsync();
                Chat!.Users.Remove(Chat.Users.FirstOrDefault(r => r.Id == userID)!);
                AlertVisible = true;
                AlertMessage = "Member removed successfully!";
                AlertColor = Color.Success;
            }
            else
            {
                AlertVisible = true;
                AlertMessage = "Member not removed";
                AlertColor = Color.Warning;
            }
        }
        catch (Exception)
        {
            AlertVisible = true;
            AlertMessage = "Sorry we failed to remove that member :( Please try again";
            AlertColor = Color.Danger;
        }
    }

    private void OnKeyPressed(object? sender, KeyEventArgs e)
    {
        if (!e.ShiftKey) return;

        IsShiftHeld = true;
        StateHasChanged();
    }

    private void OnKeyReleased(object? sender, KeyEventArgs e)
    {
        if (e.ShiftKey || !IsShiftHeld) return;

        IsShiftHeld = false;
        StateHasChanged();
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        try
        {
            KeyPressService.KeyPressed -= OnKeyPressed;
            KeyPressService.KeyReleased -= OnKeyReleased;
            await KeyPressService.StopListeningAsync();
        }
        catch (JSDisconnectedException) { /* Ignore */ }

        if (_hubConnection is null) return;

        await _hubConnection.StopAsync();
        await _hubConnection.DisposeAsync();

        _hubConnection = null;

        GC.SuppressFinalize(this);
    }

    private async Task SettingsChanged()
    {
        AlertVisible = true;
        AlertMessage = "Settings updated successfully!";
        AlertColor = Color.Success;
        await GetData();
    }
    
    private class MessageEntry
    {
        public MessageEntry? Next { get; set; }
        public MessageEntry? Previous { get; set; }
        public Message DbMessage { get; set; }
        public bool EchoRecieved { get; set; }
        
        public bool HasNext => Next != null;
        public bool HasPrevious => Previous != null;
    }
}