@inherits UserViewComponentBase

@implements IAsyncPacketSubscriber
@implements IAsyncKeySubscriber
@implements IGroupSubscriber

@using Icons = Blazorise.Icons.FontAwesome.FontAwesomeIcons
@using Bamboozlers.Classes.Services.UserServices
@using Bamboozlers.Classes.Data
@using Bamboozlers.Classes.Networking
@using Bamboozlers.Classes.Networking.Packets
@using Bamboozlers.Classes.Networking.Packets.Clientbound
@using Bamboozlers.Classes.Networking.Packets.Serverbound
@using Bamboozlers.Classes.Networking.SignalR
@using Bamboozlers.Classes.Services
@using Microsoft.AspNetCore.SignalR.Client
@using Bamboozlers.Classes
@using Blazorise.Extensions
@using AngleSharp.Diffing.Extensions
@using Microsoft.IdentityModel.Tokens
@using Bamboozlers.Classes.Utility.Observer
@using Bamboozlers.Components.Utility
@using Bamboozlers.Classes.AppDbContext
@using Bamboozlers.Classes.Func
@using Bamboozlers.Classes.Networking.Packets.Clientbound.Messaging
@using Bamboozlers.Classes.Networking.Packets.Serverbound.Chat
@using Bamboozlers.Classes.Networking.Packets.Serverbound.Messaging
@using Bamboozlers.Classes.Utility.Observer
@using Bunit.Extensions
@using System.Timers
@using Bamboozlers.Classes.Networking.Packets.Clientbound.Chat

@inject IDbContextFactory<AppDbContext> Db
@inject IJSRuntime JsRuntime
@inject AuthenticationStateProvider AuthenticationStateProvider

<!--suppress JSVoidFunctionReturnValueUsed, JSUnresolvedReference -->
<script> 
    function resizeTextarea(elementId) {
        waitForElm(`#${elementId}`).then(textarea => {
            textarea.style.height = '1px';
            textarea.style.height = (textarea.scrollHeight) + 'px';
        });
    }
    
    waitForElm("#message-input").then(textarea => {
        textarea.addEventListener('input', () => resizeTextarea('message-input'));
        textarea.addEventListener('keydown', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                e.stopPropagation();
            }
        });
        setInterval(() => resizeTextarea('message-input'), 100);
        textarea.focus();
    });
    
    function scrollToMessage(id, highlight) {
        waitForElm(`#message_${id}`).then(message => {
            let highlighted = document.querySelectorAll('.highlight');
            highlighted.forEach(e => e.classList.remove('highlight'));
            if (message) {
                message.scrollIntoView({ behavior: 'smooth', block: 'center' });
                if (highlight) {
                    message.classList.add('highlight');
                    message.addEventListener('mouseover', () => message.classList.remove('highlight'), { once: true });
                }
            }
        });
    }
    
    function scrollToBottom() {
        const messageContainer = document.getElementById('message-container');
        messageContainer.scrollTop = messageContainer.scrollHeight;
    }
    
    function scrollToElement(elementId) {
        waitForElm(`#${elementId}`).then(element => {
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        });
    }
    
    function highlightMessage(id) {
        waitForElm(`#message_${id}`).then(message => {
            if (message) {
                message.classList.add('highlight');
            }
        });
    }
    
    function unhighlightMessage(id) {
        waitForElm(`#message_${id}`).then(message => {
            if (message) {
                message.classList.remove('highlight');
            }
        });
    }
    
    function focusInput() {
        waitForElm('#message-input').then(input => input.focus());
    }
</script>
<style>
    .file-upload-button {
        cursor: pointer;
        font-size: 20px; 
        padding-right: 16px
    }
    
    .file-upload-button:hover {
        color: #9b9b9b
    }
    
    .file-upload-display {
        display: flex; 
        flex-direction: row; 
        overflow-x: scroll;
        overflow-y: hidden;
    }
</style>
<Layout>
    <LayoutHeader Fixed
                  Padding="Padding.Is3"
                  TextSize="TextSize.Heading5"
                  TextColor="TextColor.Primary"
                  Background="Background.Dark"
                  Display="Display.InlineFlex"
                  Class="justify-content-between align-items-center">
        <Div>
            @if (Chat is GroupChat groupChat)
            {
                <Image Source="@groupChat.GetGroupAvatar()" Class="message-avatar" alt=""/>
                <Div ElementId="header-text">@ChatName</Div>
            }
            else if (Chat is not null && Chat is not GroupChat)
            {
                @if(OtherUser?.Avatar != null)
                {
                    <Image Source=@($"data:image/png;base64,{Convert.ToBase64String(OtherUser.Avatar)}") Class="message-avatar" alt=""/>
                }
                <Div ElementId="header-text">
                    <CompInteractUsername User=@OtherUser/>
                </Div>
            }
        </Div>
        <Div Style="position: relative">
            <Icon ElementId="pin_button" Name="Icons.MapPin" Style="margin-right: 0.5em" Class="button-tooltip tooltip-left" data-tooltip="Pins" role="button" @onclick="() => OpenKnownPopup.InvokeAsync(new KnownPopupArgs(PopupType.Pins, Self, ChatID, async arg => await JumpToMessage((Message)arg!)))"/>
            @if (Chat is GroupChat)
            {
                <Icon ElementId="settingsbtn" Name="IconName.Settings" role="button" @onclick="async () => await OpenKnownPopup.InvokeAsync(new KnownPopupArgs(PopupType.GroupChatSettings, ChatId: ChatID))"/>
            }
        </Div>
    </LayoutHeader>
    <LayoutContent Padding="Padding.Is3" ElementId="message-container" Class="scrollbar-container h-100">
        <Layout>
            <LayoutContent>
                <Div>
                    @if (ChatLoaded)
                    {
                        <CascadingValue Value="new ChatContext(IsMod,  SetReplying, DeleteMessage, StartEditMessage, SetLastEdit, EndEditMessage, PinMessage)">
                            @foreach (var message in Messages)
                            {
                                <CompMessageView
                                    Message="message.DbMessage"
                                    PreviousMessage="@message.Previous?.DbMessage"
                                    EchoRecieved="@message.EchoRecieved"
                                    Editing="@message.DbMessage.ID.Equals(_editingMessage?.DbMessage.ID)"/>
                            }
                        </CascadingValue>
                    }
                </Div>
            </LayoutContent>
        </Layout>
    </LayoutContent>
    <LayoutFooter>
        <Div Position="Position.Sticky" Style="margin: 20px 20px 35px; border-radius: 5px;">
            @if (_replyingTo != null)
            {
                <Div Background="Background.Dark" Padding="Padding.Is2">
                    <Div class="text-muted" style="display: flex; flex-direction: row; align-items: center" Width="Width.Is100">
                        Replying to
                        <Div style="font-size: 16px; font-weight: bold; margin-left: 5px">
                            @(_replyingTo.DbMessage.Sender!.DisplayName ?? _replyingTo.DbMessage.Sender.UserName)
                        </Div>
                        <Icon Name="Icons.CircleXmark" @onclick="() => _replyingTo = null" Style="margin-left: auto; margin-right: 5px; cursor: pointer;" Class="fa-lg"/>
                    </Div>
                </Div>
            }
            @if(FileData.Count >0)
            {
                <Div Background="Background.Secondary" Class="file-upload-display scrollbar-container">
                    @foreach (var file in FileData)
                    {
                        <CompFileUpload FileName="@file.Key" FileData="@file.Value" OnRemove="@(async () => await RemoveFile(file.Key))"/>
                    }
                </Div>
            }
            <Div Background="Background.Secondary" TextColor="TextColor.Light" Style="display: flex; flex-direction: row; align-items: center; flex-grow: initial">
                <Div Style="margin-left: 20px; position: relative">
                    <Label for="input-file" Style="margin-bottom: 0">
                        <Div Class="button-tooltip tooltip-right file-upload-button" data-tooltip="Upload File">
                            <Icon Class="@Icons.FileCirclePlus"></Icon>
                        </Div>
                    </Label>
                    <InputFile id="input-file" OnChange="@OnFileUpload" hidden multiple/>
                </Div>
                <Div Display="Display.Flex" Overflow="Overflow.Hidden" Width="Width.Is100">
                    <textarea id="message-input" placeholder="@($"Message {ChatName}")" class="message-input p-3" style="padding-left: 0 !important;" @onkeyup="OnInput" @bind="MessageInput" @bind:event="oninput">
                    </textarea>
                </Div>
            </Div>
            <CompTypingView ChatID="@ChatID"/>
        </Div>
    </LayoutFooter>
</Layout>
<LayoutSider>
    <LayoutSiderContent>
        <Bar Mode="BarMode.VerticalInline"
             CollapseMode="BarCollapseMode.Hide"
             ThemeContrast="ThemeContrast.Dark"
             Class="h-100">
            <BarMenu>
                <BarItem Class="mb-2">
                    <Div TextColor="TextColor.Primary"
                         Background="Background.Dark"
                         Padding="Padding.Is3"
                         TextSize="TextSize.Large">
                        @if (Chat is GroupChat)
                        {
                            <span class="me-4">Members - @Chat.Users.Count</span>
                            @if (IsMod)
                            {
                                <Icon ElementId="addMembers"
                                      role="button"
                                      Name="IconName.Add"
                                      @onclick="async () => await OpenKnownPopup.InvokeAsync(new KnownPopupArgs(PopupType.InviteGroupMembers, null, ChatID))"/>
                            }
                        }
                        else
                        {
                            <span class="me-4">Direct Message</span>
                        }
                    </Div>
                </BarItem>
                @if (Chat is not null)
                {
                    @foreach (var user in Chat.Users)
                    {
                        <BarItem>
                            <BarLink Flex="Flex.JustifyContent.Between" class="align-items-center rounded" Display="Display.Flex">
                                <Div>
                                    @if (user.Avatar != null)
                                    {
                                        <Image Source="@user.GetAvatar()" Class="message-avatar" alt=""/>
                                    }
                                    <CompInteractUsername User="@user"/>
                                </Div>
                            </BarLink>
                        </BarItem>
                    }
                }
            </BarMenu>
        </Bar>
    </LayoutSiderContent>
</LayoutSider>

@* ReSharper disable always InconsistentNaming *@
@code {
    [Inject] IUserGroupService UserGroupService { get; set; } = default!;

    [CascadingParameter] public EventCallback<KnownPopupArgs> OpenKnownPopup { get; set; }
    [CascadingParameter] public EventCallback ClosePopupCallback { get; set; }
    [CascadingParameter] public EventCallback<IPacket> SendToServer { get; set; }
    [CascadingParameter] public Predicate<IAsyncPacketSubscriber> AddPacketSubscriber { get; set; }
    [CascadingParameter] public Predicate<IAsyncKeySubscriber> AddKeySubscriber { get; set; }

    [Parameter] public int? ChatID { get; set; }
    private Chat? Chat { get; set; }
    private string ChatName { get; set; }
    private bool ChatLoaded { get; set; }

    private User? _otherUser;

    /// <summary>
    ///     Null if the chat is a group chat
    /// </summary>
    private User? OtherUser
    {
        get
        {
            if (Chat is GroupChat) return null;

            return _otherUser ??= Chat?.Users.FirstOrDefault(u => u.Id != Self!.Id);
        }
        set => _otherUser = value;
    }

    public List<int?> WatchedIDs { get; private set; } = [];

    private User? Self { get; set; }
    private bool IsMod { get; set; }

    private List<MessageEntry> Messages { get; set; } = [];
    private Dictionary<int, int> MessageIdToIndex { get; set; } = new();
    private List<int> EphemeralMessages { get; set; } = [];
    private string MessageInput { get; set; }

    private MessageEntry? _editingMessage;
    private string? LastEdit { get; set; }

    private MessageEntry? _replyingTo;
    
    private Dictionary<string, byte[]> FileData { get; set; } = new();
    
    protected override async Task OnInitializedAsync()
    {
        UserGroupService.AddSubscriber(this);
        Self = (await AuthService.GetUser())!;
    }

    protected override async Task OnParametersSetAsync()
    {
        WatchedIDs = [ChatID];
        await GetChatData();
        IsMod = IsModerator();

        await using var db = await Db.CreateDbContextAsync();
        Chat = await db.Chats
            .Include(c => c.Users)
            .FirstOrDefaultAsync(c => c.ID == ChatID);
        ChatName = Chat switch
        {
            null => throw new InvalidOperationException($"Chat from ID {ChatID} not found"),
            GroupChat groupChat => groupChat.GetGroupName(),
            _ => (OtherUser!.DisplayName ?? OtherUser!.UserName)!
        };

        await InitMessages();

        ChatLoaded = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        AddPacketSubscriber.Invoke(this);
        AddKeySubscriber.Invoke(this);
        await SendToServer.InvokeAsync(new JoinChatC2SPacket { ChatId = (int)ChatID! });
        await JsRuntime.InvokeVoidAsync("setTimeout", "scrollToBottom()", 200);
    }

    public async Task OnPacket(IPacket packet)
    {
        switch (packet)
        {
            case MessageSentS2CPacket messageSent:
                await RecieveMessage(messageSent.MessageId);
                await InvokeAsync(StateHasChanged);
                break;
            case MessageDeletedS2CPacket messageDeleted:
                await RemoveClientMessage(messageDeleted.MessageId);
                break;
            case MessageEditedS2CPacket messageEdited:
            {
                await using var db = await Db.CreateDbContextAsync();
                var message = await db.Messages.Include(m => m.Sender).FirstAsync(m => m.ID == messageEdited.MessageId);
                Messages[MessageIdToIndex[messageEdited.MessageId]].DbMessage = message;
                await InvokeAsync(StateHasChanged);
                break;
            }
            case MessagePinStatusS2CPacket pinStatus:
            {
                await using var db = await Db.CreateDbContextAsync();
                var message = await db.Messages.Include(m => m.Sender).FirstAsync(m => m.ID == pinStatus.MessageId);
                Messages[MessageIdToIndex[pinStatus.MessageId]].DbMessage = message;
                await InvokeAsync(StateHasChanged);
                break;
            }
        }
    }

    private bool IsModerator()
    {
        if (Chat is not GroupChat)
            return false;

        using var db = Db.CreateDbContext();
        var gc = db.GroupChats
            .Include(i => i.Moderators)
            .AsNoTracking()
            .First(f => f.ID == ChatID);
        return gc.OwnerID == Self!.Id || gc.Moderators.Any(m => m.Id == Self.Id);
    }

    private async Task GetChatData()
    {
        await using var db = await Db.CreateDbContextAsync();
        Chat = await db.Chats
            .Include(i => i.Users)
            .Include(i => i.Messages)
            .FirstOrDefaultAsync(c => c.ID == ChatID);

        if (Chat is GroupChat)
        {
            Chat = await db.GroupChats
                .Include(i => i.Users)
                .Include(i => i.Messages)
                .Include(i => i.Owner)
                .FirstOrDefaultAsync(c => c.ID == ChatID);
        }

        if (Self is null || Chat is null)
            return;

        switch (Chat)
        {
            case null:
                throw new InvalidOperationException($"Chat from ID {ChatID} not found");
            case GroupChat gc:
                ChatName = gc.GetGroupName();
                break;
            default:
            {
                var self = await AuthService.GetUser();
                var other = Chat.Users.FirstOrDefault(u => u.Id != self!.Id) ?? self!;
                ChatName = other.GetName();
                break;
            }
        }
    }

    private void ReIndexMessages()
    {
        MessageIdToIndex.Clear();
        for (var i = 0; i < Messages.Count; i++)
        {
            MessageIdToIndex[Messages[i].DbMessage.ID] = i;
        }
    }

    private async Task OnInput(KeyboardEventArgs eventArgs)
    {
        if (eventArgs.Key != "Enter" || eventArgs.ShiftKey) return;

        await SendMessage(MessageInput);
        MessageInput = "";
    }

    private async Task DeleteMessage(Message message)
    {
        await using var db = await Db.CreateDbContextAsync();
        db.Messages.Remove(message);
        await db.SaveChangesAsync();

        var messageDeleted = new MessageDeletedC2SPacket
        {
            SenderId = Self!.Id,
            ChatId = (int)ChatID!,
            MessageId = message.ID
        };

        await SendToServer.InvokeAsync(messageDeleted);
    }

    private async Task RemoveClientMessage(int messageId)
    {
        var target = Messages[MessageIdToIndex[messageId]];
        if (target.Previous != null)
        {
            target.Previous.Next = target.Next;
        }

        if (target.Next != null)
        {
            target.Next.Previous = target.Previous;
        }

        Messages.Remove(target);
        ReIndexMessages();

        await InvokeAsync(StateHasChanged);
    }

    private async Task SetReplying(Message toMessage)
    {
        _replyingTo = Messages[MessageIdToIndex[toMessage.ID]];
        await JsRuntime.InvokeVoidAsync("highlightMessage", toMessage.ID);
        await JsRuntime.InvokeVoidAsync("focusInput");
        await InvokeAsync(StateHasChanged);
    }

    private async Task StopReplying()
    {
        await JsRuntime.InvokeVoidAsync("unhighlightMessage", _replyingTo!.DbMessage.ID);
        _replyingTo = null;
        await InvokeAsync(StateHasChanged);
    }

    private Task SetLastEdit(string? lastEdit)
    {
        LastEdit = lastEdit;
        return Task.CompletedTask;
    }

    private async Task StartEditMessage(Message message)
    {
        _editingMessage = Messages[MessageIdToIndex[message.ID]];
        await JsRuntime.InvokeVoidAsync("startEdit");
        await JsRuntime.InvokeVoidAsync("ensureInView", message.ID);
        await InvokeAsync(StateHasChanged);
    }

    private async Task EndEditMessage(bool cancel)
    {
        if (cancel || _editingMessage == null || LastEdit == null || LastEdit == _editingMessage.DbMessage.Content)
        {
            await StopEditing();
            return;
        }

        if (LastEdit.Equals(string.Empty))
        {
            await DeleteMessage(_editingMessage.DbMessage);
            await StopEditing();
            return;
        }

        await using var db = await Db.CreateDbContextAsync();
        _editingMessage.DbMessage.Content = LastEdit;
        _editingMessage.DbMessage.EditedAt = DateTime.Now;
        db.Messages.Update(_editingMessage.DbMessage);
        await db.SaveChangesAsync();

        var messageEdited = new MessageEditedC2SPacket
        {
            SenderId = Self!.Id,
            MessageId = _editingMessage.DbMessage.ID,
            ChatId = (int)ChatID!,
            NewContent = LastEdit
        };
        await SendToServer.InvokeAsync(messageEdited);
        await StopEditing();
    }

    private async Task StopEditing()
    {
        _editingMessage = null;
        await InvokeAsync(StateHasChanged);
    }

    private async Task PinMessage(Message message)
    {
        await using var db = await Db.CreateDbContextAsync();
        message.PinnedAt = message.IsPinned ? null : DateTime.Now;
        db.Messages.Update(message);
        await db.SaveChangesAsync();

        var pinStatus = new MessagePinStatusC2SPacket
        {
            SenderId = Self!.Id,
            ChatId = (int)ChatID!,
            MessageId = message.ID,
            Pinned = message.IsPinned
        };
        await SendToServer.InvokeAsync(pinStatus);
    }

    private async Task JumpToMessage(Message message, bool highlight = true)
    {
        await JsRuntime.InvokeVoidAsync("scrollToMessage", message.ID, highlight);
    }

    public async Task InitMessages()
    {
        await using var db = await Db.CreateDbContextAsync();
        var messages = await db.Messages
            .Include(m => m.Sender)
            .Include(m => m.Attachments)
            .Where(m => m.ChatID == Chat!.ID)
            .ToListAsync();

        foreach (var message in messages)
        {
            if (EphemeralMessages.Contains(message.ID))
            {
                EphemeralMessages.Remove(message.ID);
                Messages[MessageIdToIndex[message.ID]].EchoRecieved = true;
            }
            else if (MessageIdToIndex.TryGetValue(message.ID, out var messageIndex))
            {
                Messages[messageIndex].DbMessage = message;
            }
            else
            {
                CreateMessageEntry(message);
            }
        }
    }

    private async Task RecieveMessage(int messageId)
    {
        if (EphemeralMessages.Contains(messageId))
        {
            EphemeralMessages.Remove(messageId);
            Messages[MessageIdToIndex[messageId]].EchoRecieved = true;
        }
        else if (MessageIdToIndex.TryGetValue(messageId, out var messageIndex))
        {
            Messages[messageIndex].EchoRecieved = true;
        }
        else
        {
            await using var db = await Db.CreateDbContextAsync();
            var message = await db.Messages
                .Include(m => m.Sender)
                .Include(m => m.Attachments)
                .FirstAsync(m => m.ID == messageId);
            CreateMessageEntry(message);
            await JumpToMessage(message, false);
        }
    }

    private async Task SendMessage(string messageText)
    {
        if (string.IsNullOrWhiteSpace(messageText) && FileData.Count == 0) return;
        messageText = string.IsNullOrWhiteSpace(messageText) ? "" : messageText;

        while (messageText.EndsWith("\n")) messageText = messageText[..^1];
        while (messageText.StartsWith("\n")) messageText = messageText[1..];

        var self = await AuthService.GetUser();
        var message = new Message
        {
            ChatID = (int)ChatID!,
            SenderID = self!.Id,
            Content = messageText,
            SentAt = DateTime.Now
        };
        
        if (FileData.Count > 0)
        {
            message.Attachments = [];
            foreach (var filename in FileData.Keys)
            {
                message.Attachments.Add(new MessageAttachment
                {
                    FileName = filename,
                    Data = FileData[filename]
                });
            }
            FileData.Clear();
        }
        
        if (_replyingTo != null)
        {
            message.ReplyToID = _replyingTo.DbMessage.ID;
            await StopReplying();
        }

        await using var db = await Db.CreateDbContextAsync();
        db.Messages.Add(message);
        await db.SaveChangesAsync();

        CreateMessageEntry(message, true);
        await InvokeAsync(StateHasChanged);
        await JumpToMessage(message, false);

        var typingPacket = new TypingStateC2SPacket
        {
            ChatId = (int)ChatID!,
            SenderId = self.Id,
            Typing = false
        };
        await SendToServer.InvokeAsync(typingPacket);
        
        var messageSent = new MessageSentC2SPacket
        {
            SenderId = self.Id,
            ChatId = (int)ChatID!,
            MessageId = message.ID
        };
        await SendToServer.InvokeAsync(messageSent);
    }

    private async Task OnFileUpload(InputFileChangeEventArgs args)
    {
        IReadOnlyList<IBrowserFile> files;
        try
        {
            files = args.GetMultipleFiles();
        }
        catch (InvalidOperationException)
        {
            Console.WriteLine("Failed to read file");
            return;
        }

        foreach (var file in files)
        {
            using var ms = new MemoryStream();
            await file.OpenReadStream(maxAllowedSize: 1024 * 1024 * 100).CopyToAsync(ms);
            FileData[file.Name] = ms.ToArray();
        }
        await InvokeAsync(StateHasChanged);
        await JsRuntime.InvokeVoidAsync("focusInput");
    }
    
    private async Task RemoveFile(string filename)
    {
        FileData.Remove(filename);
        await InvokeAsync(StateHasChanged);
        await JsRuntime.InvokeVoidAsync("focusInput");
    }

    private MessageEntry CreateMessageEntry(Message message, bool ephemeral = false)
    {
        var lastMessage = Messages.Count == 0 ? null : Messages[^1];
        var messageEntry = new MessageEntry
        {
            DbMessage = message,
            Previous = lastMessage,
            Next = null,
            EchoRecieved = !ephemeral
        };
        if (lastMessage != null)
        {
            lastMessage.Next = messageEntry;
        }

        Messages.Add(messageEntry);
        MessageIdToIndex[message.ID] = Messages.Count - 1;
        if (ephemeral)
        {
            EphemeralMessages.Add(message.ID);
        }

        return messageEntry;
    }

    public async Task OnKeyPressed(KeyEventArgs keyEventArgs)
    {
        await Task.CompletedTask;
    }

    public async Task OnKeyReleased(KeyEventArgs keyEventArgs)
    {
        if (_editingMessage != null)
        {
            switch (keyEventArgs.Key)
            {
                case "Escape":
                    await StopEditing();
                    break;
                case "Enter" when !keyEventArgs.ShiftKey:
                {
                    await EndEditMessage(false);
                    break;
                }
            }
        }
        else
        {
            if (keyEventArgs.Key == "ArrowUp")
            {
                var lastMessage = Messages.LastOrDefault(m => m.DbMessage.SenderID == Self!.Id);
                if (lastMessage != null)
                {
                    await StartEditMessage(lastMessage.DbMessage);
                }
            }
        }

        if (_replyingTo != null)
        {
            switch (keyEventArgs.Key)
            {
                case "Escape":
                    await StopReplying();
                    break;
            }
        }
    }

    public List<GroupEvent> WatchedGroupEvents { get; } =
    [
        GroupEvent.GroupDisplayChange,
        GroupEvent.RemoveMember
    ];

    public async Task OnUpdate(GroupEvent evt, int? specifiedGroup = null)
    {
        await GetChatData();
    }

    private class MessageEntry
    {
        public MessageEntry? Next { get; set; }
        public MessageEntry? Previous { get; set; }
        public Message DbMessage { get; set; }
        public bool EchoRecieved { get; set; }

        public bool HasNext => Next != null;
        public bool HasPrevious => Previous != null;
    }

}