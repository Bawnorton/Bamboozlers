@using Bamboozlers.Classes.AppDbContext
@using Bamboozlers.Classes
@inject IJSRuntime JsRuntime
@implements IDisposable

<Layout ElementId="message-container" Style="height: 92%" Class="scrollbar-container">
    <LayoutContent>
        <Div>
            @foreach (var message in Messages)
            {
                <CompMessageView Message="message.Message" MessageState="@message.GetMessageState()"></CompMessageView>
            }
        </Div>
    </LayoutContent>
</Layout>
<Div Position="Position.Sticky" Background="Background.Secondary" TextColor="TextColor.Light" Style="bottom: 0">
    <Div Display="Display.Flex" Overflow="Overflow.Hidden">
        <Div @ref="MessageInput" contenteditable="true" Width="Width.Is100" Height="Height.Is100" Padding="Padding.Is3"
             id="message-input" class="message-input" data-placeholder="@($"Message {ChatName}")">
        </Div>
    </Div>
</Div>

@code {
    [Parameter]
    public Chat? Chat { get; set; }
    
    private User Self { get; set; }

    private Div MessageInput { get; set; }
    
    private Layout ScrollContainer { get; set; }
        
    private string ChatName { get; set; }
    
    private string TypedMessage { get; set; }

    private List<LinkedMessage> Messages { get; set; } = [];
    
    private DotNetObjectReference<CompChatView> Reference { get; set; }
    
    protected override async Task OnInitializedAsync()
    {
        Self = await AuthHelper.GetSelf();
        if (Chat is GroupChat groupChat)
        {
            ChatName = groupChat.Name;
        }
        else if (Chat is not null)
        {
            var other = Chat.Users.First(u => u.Id != Self.Id);
            ChatName = (other.DisplayName ?? other.UserName)!;
        }
        else
        {
            throw new InvalidOperationException("Chat is null");
        }

        var messages = new List<Message>(Chat?.Messages ?? []);
        messages.Sort((a, b) => a.SentAt.CompareTo(b.SentAt));
        var linkedMessages = messages.Select((t, i) => new LinkedMessage(t, i > 0 ? messages[i - 1] : null)).ToList();
        Messages = linkedMessages;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Reference = DotNetObjectReference.Create(this);
            await JsRuntime.InvokeVoidAsync("messageInputInterop.init", Reference, "message-input");
        }
    }
    
    [JSInvokable]
    public Task<IEnumerable<KeyReference>> GetDisallowedKeys()
    {
        return Task.FromResult<IEnumerable<KeyReference>>([
            KeyReference.Normal("Enter", "Enter")
        ]);
    }

    /// <summary>
    /// Before text is inserted into the contenteditable element
    /// </summary>
    [JSInvokable]
    public async void OnKeydown(InputEvent inputEvent)
    {
        var keyReference = inputEvent.KeyReference;
        if (keyReference is { Key: "Enter", Shift: false })
        {
            await JsRuntime.InvokeVoidAsync("messageInputInterop.clear", "message-input");
            SendMessage();
            StateHasChanged();
        } 
    }
    
    /// <summary>
    /// After text is inserted into the contenteditable element
    /// </summary>
    [JSInvokable]
    public async void OnKeyup(InputEvent inputEvent)
    {
        TypedMessage = inputEvent.Text;
        switch (inputEvent.KeyReference)
        {
            case { Key: "Backspace" } when TypedMessage.Equals("\n"):
                await JsRuntime.InvokeVoidAsync("messageInputInterop.clear", "message-input");
                break;
            case { Key: "Enter", Shift: false }:
                await JsRuntime.InvokeVoidAsync("messageInputInterop.scrollToBottom", "message-container");
                break;
        }
    }

    private void SendMessage()
    {
        if (string.IsNullOrWhiteSpace(TypedMessage))
        {
            return;
        }
        var message = new Message
        {
            Sender = Self,
            SenderID = Self.Id,
            SentAt = DateTime.Now,
            Content = TypedMessage
        };
        Messages.Add(new LinkedMessage(message, Messages.Last().Message));
    }
    
    public void Dispose()
    {
        Reference.Dispose();
    }

    public record InputEvent(KeyReference KeyReference, string Text, bool Passed);

    public record KeyReference(string Key, string Code, bool Ctrl, bool Shift, bool Alt, bool Meta)
    {
        public static KeyReference Normal(string key, string code) => new(key, code, false, false, false, false);
    }
    
    public class LinkedMessage(Message message, Message? previous)
    {
        public MessageState GetMessageState()
        {
            if (previous is null)
            {
                return MessageState.First;
            }
            return previous.SenderID == Message.SenderID ? MessageState.SameUser : MessageState.NewUser;
        }
        
        public Message Message { get; } = message;
    }
}
